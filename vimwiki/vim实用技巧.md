:vim 实用技巧:
[TOC]

- 启用高亮查找`:set hlsearch`
- 彻底禁用高亮查找`:set nohlsearch`
- 暂时关闭高亮查找`:nohlsearch`,高亮功能会一直关闭，直到执行新的或重复的查找命令

> 创建用于关闭高亮查找功能的快捷键
> 虽然`:noh <CR>`也可以暂时关闭高亮查找的功能，但是也会花费不少功夫，可以创建映射项来加速操作:
> 例如:
> `noremap<silent> <C-l> :<C-u> nohlsearch<CR><C-l>` > `<C-l>`通常用于清除并重绘显示屏，上面的映射是在原有的基础上增加了暂时关闭查找高亮的功能

### 第一章 Vim 解决问题的方式

#### 技巧1 '.' 命令;

'.' 命令可以重复上一次的修改，'.'

> 插入模式中移动光标也会重置修改状态.

#### 技巧30 指定范围内执行普通模式命令

全文件的每一行末尾添加一个分号：
`:%normal A;`

为选中的区域执行'.'操作:
`:'<,'>normal .`

为指定范围的行执行'.'操作:
`:17,25normal .`

先执行 A;然后再为全文件每一行

#### 技巧2 不要自我重复

##### 减少无关移动

要在行末尾添加';':

- <kbd>$</kbd><kbd>a</kbd><kbd>;</kbd><kbd>ESC</kbd>
- <kbd>A</kbd><kbd>;</kbd><kbd>ESC</kbd>

第二种方法比第一种少按一个按键.就是减少了不必要的移动操作$导致的，类似这样的例子很多。书中表:

**一箭双雕**

| 复合命令 | 等效的长命令 |
| :------: | :----------: |
|    C     |      c$      |
|    s     |      cl      |
|    S     |      ^C      |
|    I     |      ^i      |
|    A     |      $a      |
|    o     |    A<CR>     |
|    O     |      ko      |

---

#### 技巧3 以退为进(使操作可重复)

##### 使修改可重复

下面的 JS 代码中连接字符串的代码不是很易读:
`var foo = "method("+argument1+","+argument2+")";`

要改成这种更易读的：  
`var foo = "method(" + argument1 + "," + argument2 + ")";`

可以先添加加号前面的空格，再添加后面的空格，再重复这个操作

也可以用这个技巧:

> Take One Step Back ,Then Three Forward.

| KeystrokesBuffer | Contents                                                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| {start}          | <span style="background-color: blue;"><font color="white">v</font></span>ar foo = "method("+argument1+","+argument2+")";                    |
| f+               | var foo = "method("<span style="background-color: blue;"><font color="white">+</font></span>argument1+","+argument2+")";                    |
| s␣+␣<Esc>        | var foo = "method(" +<span style="background-color: blue;"><font color="white">&nbsp;&nbsp;</font></span>argument1+","+argument2+")";       |
| ;                | var foo = "method(" + argument1<span style="background-color: blue;"><font color="white">+</font></span>","+argument2+")";                  |
| .                | var foo = "method(" + argument1 +<span style="background-color: blue;"><font color="white">&nbsp;&nbsp;</font></span>","+argument2+")";     |
| ;.               | var foo = "method(" + argument1 + "," +<span style="background-color: blue;"><font color="white">&nbsp;&nbsp;</font></span>argument2+")";   |
| ;.               | var foo = "method(" + argument1 + "," + argument2 +<span style="background-color: blue;"><font color="white">&nbsp;&nbsp;</font></span>")"; |

##### 使移动可重复

在 vim 中移动光标的操作 hjkl 是不能用'.'操作来重复的,但是可以用`[count]motion`这种方式来重复执行,`5j`就是向下移动 5 行;但是向上面的例子里，要修改的是每一个+号前后的文本，总是去数要移动几个字符就太勤奋了，vim 有查找字符的功能 F ｜ f ｜ t ｜ T ｜仅作用于当前行,而通过这种方式可以在当前行跳到光标想要到达的位置，这种方式还可以通过`;`和`,`来重复执行(分号向下重复，逗号向上重复)

> f{char} for find forward,t for till forward.
> ; repeate last f,F,t,T command [count] times.

##### 合二为一

`;`命令能重复上一个`F,f,T,t`命令，`.`命令重复上一次的修改.

> Instead of fighting Vim’s modal input model, we’re working with it, and look
> how much easier it makes this particular task.

---

#### 技巧4 执行、重复、回退

> Act,Repeat,Reverse

|              Intent              |          Act          | Repeat | Reverse |
| :------------------------------: | :-------------------: | :----: | :-----: |
|          Make a change           |        {edit}         |   .    |    u    |
|   Scan line for next character   |    f{char}/t{char}    |   ;    |    ,    |
| Scan line for previous character |   F{char} / T{char}   |   ;    |    ,    |
|   Scan document for next match   |     /pattern <CR>     |   n    |    N    |
| Scan document for previous match |     ?pattern<CR>      |   n    |    N    |
|       Perform substitution       | :s/target/replacement |   &    |    u    |
|  Execute a sequence of changes   |     qx{changes}q      |   @x   |    u    |

#### 技巧5 查找并手动替换

> find and replace by hand

`*`可以查找光标所在位置的**单词**(对中文的支持就不是很好,对 vim 来说，只有空格，标点隔开的中文文本才是一个单词,想只查找一个词还得用`/`命令),`*`命令就是'/'命令查找单词的快捷方式

`cw`change word 直接删除**单词**并进入插入模式,`ESC`回到普通模式,再就可以用`n`重复上一次查找，`.`重复上一次修改了。而且这种查找替换方式可以决定每一个查找的词是否需要替换。

> 这里 Vim 提高编辑速度的重点是让移动和修改都可重复

#### 技巧6 `.`范式

> 理想的多个相同的编辑任务的编辑模式: 一键移动，一键执行.

上面的几个例子都是只需要按下一次按键就能找到下一个目标位置，按下一次按键就能执行修改任务，也都是用`.`命令重复上次的修改任务，为了方便起见，将这种编辑模式成为`.`范式

> for the sake of convenience, we'll refer to this pattern as the **Dot Formula**

## 第一部分

### 第二章 普通模式

#### 技巧7 停顿时清移开画笔

画家作画除了用画笔在画布上作画，还要研究主题，调整光线，调颜料颜色，
还会用刻刀或其它东西像是棉签来调整画好的地方.

> 画家在休息时不会把画笔放在画布上，对 Vim 而言也是这样，普通模式就是 Vim 的放松状态，Normal 这个名字就寓示了这一点.

#### 技巧8 把撤销单元切成块

`u`会触发撤销命令，撤销最新的修改.一次修改可以使改变文档内文本的任意操作，其中包括在普通模式、可视模式以及命令行模式中所触发的命令，而且一次修改也包括了在插入模式中输入(删除)的文本，因此`i{insert some text}<ESC>`是一次修改。

别的编辑器中撤销命令可能会撤销最后输入的字符，也可能以单词为单位撤销，但是 vim 可以控制撤销的粒度

从进入插入模式开始，到返回普通模式为止，这期间修改的任何内容都被当成是一次修改，因此只要控制好`<ESC>`的使用，就可以让撤销命令作用于单词、句子或段落。

> 插入模式下按` <Up>``<Down>``<Left>``<Right> `时，相当与先切换回了普通模式，然后用 hjkl 移动了光标，再进入了插入模式,因此这会对`.`命令产生影响

#### 技巧9 构造可重复的修改

##### 删除单词

- 光标在单词末尾:`dbx`: `db`删除从光标开始到单词开头的内容，但会留下光标位置的字符，还需要按`x`进行删除
- 光标在单词末尾:`bdw`: `b`命令移动光标到单词开头，`dw`命令删除光标到单词末尾的内容
- 光标在单词任意位置:`daw`: "delete a word"只要光标在单词任意位置就能删除整个单词

这三种都是删除了整个单词，而且都只用按 3 次按键，但是前面两种是执行了两个命令，就不能用`.`命令重复删除单词的操作了，第三种是一个命令，可以用`.`命令重复，并且`daw`会帮助删除单词前面的空格，执行删除操作后会自动删除前面或后面的空格，使光标停在下一个单词首字母(尾字母)视被删除的单词的位置而定。

> 只为了删除某个单词就用`daw`,删除光标当前位置到单词首尾就用`dw`/`db`

---

> 需要在几个地方做同样的修改时，尝试改造修改，使`.` 命令能重复执行该修改

---

#### 技巧10 用次数做简单的算术运算

> 大多数普通模式命令可以在执行时指定次数，可以利用这个功能来做简单的算术运算

`<C-a>`和`<C-x>`命令分别对当前光标之上或之后的数字执行加和减的操作。将光标移到数字上执行一次可以对数字进行加减 1 的操作;光标不在数字上会将光标跳到下一个数字处并执行加减的操作.

> 当对 007 进行加运算的时候，结果产生的是 010,这是因为 vim 把 0 开头的数字解释为八进制

**octal-nrfotmats**

| base  | Prefix |
| :---: | :----: |
| octal |   0    |
|  hex  | 0X/0x  |
|  bin  | 0b/0B  |

> 这是 vim 的缺省行为，如果想要关闭这种进制运算，可以使用这个设置：`set nrformats=` 这会让 Vim 把所有数字当成十进制

#### 技巧11 能够重复，就别用次数

> 某些情况下，使用次数能使按键次数变得最少，但是并不是非得这样不可。

Delete <span style="background-color:grey">m</span>ore than one word

从光标处删除两个单词，可以使用`d2w`或者`2dw`或者`dw.`
前面两个使用了次数，后面使用`.`命令重复，前面的修改粒度是两个单词，后面的修改粒度是一个单词，具体想使用哪个视情况而定

#### 技巧12 双剑合璧(操作符+动作命令=操作)

`d{motion}`命令可以删除字符(`dl`)，删除完整单词(`daw`)或者整个段落(`dap`),`d`操作符的操作范围由动作命令决定。`c{motion}`、
`y{motion}`以及其他类似的命令，被称为操作符(operator)，

**常见 vim 操作符**

| 命令 |                 用途                 |
| ---- | :----------------------------------: |
| `c`  |                 修改                 |
| `d`  |                 删除                 |
| `y`  |             复制到寄存器             |
| `g~` |              反转大小写              |
| `gu` |              转换为小写              |
| `gU` |              转换为大写              |
| `>`  |               增加缩进               |
| `<`  |               减小缩进               |
| `=`  |               自动缩进               |
| `!`  | 使用外部程序过滤`{motion}`所跨越的行 |

> 自定义操作符`:help map-operator` 自定义动作命令`:help omap-info`

---

**操作符待决模式**

> 普通、插入和可视模式很容易识别，但是 vim 也有一些容易被忽视的模式，操作符待决模式(operator-pending mode)，就是一个例子;在执行`dw`时就会激活该模式，该模式只在` d``w `之间的短暂时间间隔存在。
> 也有其他命令是由两个或更多的按键来调用的:` :h g``:h z``:h ctrl-w``:h [ `,可以看到一些例子 ，但多数情况下,头一个按键是第二个按键的前缀，这样的命令不会激活操作符待决模式，可以把他们当作是命名空间(namespace),用来扩充命令数目的，
> 只有操作符(operator)才会激活操作符待决模式

Q: 为什么命名空间只是普通模式的扩充，而操作符和动作之间有一个完整的操作符待决模式？  
A: 因为操作符和动作可以自定义，可以扩充 Vim 的词汇

Vim 的词汇：`daw`中`d`是删除，`aw`就表示一个完整单词,这里`d`,`aw`就是词汇,delete a word ,那要修改一个单词用`c`,就可以用`caw`了。

自定义: Vim 里没有`al`，a line 这个词汇(动作),那你就可以自定义`al`动作，用`dal`来删除一行。

`:onoremap al :<c-u>normal! ^v$<cr>`

**一般规则**
下面两条规则可以让你可以很直观的以多种方式创建 operator-pending 映射：

- 如果你的 operator-pending 映射以在可视模式下选中文本结束，Vim 会操作这些文本。
- 否则，Vim 会操作从光标的原始位置到一个新位置之间的文本。

---

### 第三章 插入模式

#### 技巧13 再插入模式中即可更正错误

> 在插入模式写文本时出了错，可以立刻对其进行更正，而无须切换模式，除了用退格键，还可以使用插入模式中的一些命令。

在插入模式下，退格键可以删除光标前的字符，另外，也可以用下面的组合键：

| 按键操作 |           用途           |
| :------: | :----------------------: |
|  `C-h`   | 删除前一个字符(同退格键) |
|  `C-w`   |      删除前一个单词      |
|  `C-u`   |        删除至行首        |

#### 技巧14 返回普通模式

**切换普通模式**
| 按键操作 | 用途 |
|:--------:|:-------------------:|
| `<ESC>` | 切换到普通模式 |
| `<C-[>` | 切换到普通模式 |
| `C-o` | 切换到插入-普通模式 |

> Vim 模式区分的特点，使想要运行某个普通模式命令并马上回到原来位置继续输入时较为繁琐.为了减少切换模式带来的不畅，Vim 提供了插入-普通模式.

##### 插入-普通模式

---

> `zz`命令能重绘窗口，并把当前行显示在窗口正中。

---

当前行在窗口底部或顶部编辑时按
`<C-o>zz`在普通-插入模式中触发`zz`，操作完成后当前行回到屏幕正中，并仍然处于插入模式.

#### 技巧15 不离开插入模式，粘贴寄存器中的文本

---

**重新映射`<Caps Lock>`**

> 对 Vim 来说，大小写切换键是是一个威胁，很多用户会将`<Caps Lock>`映射为`<ESC>`或者`<Ctrl>`,系统级别的映射各操作系统不一样

---

复制命令`y`会把复制的文本复制到复制专用[寄存器](#)中,
在插入模式下，按`<C-r>0`会把刚才复制的文本粘贴到光标所在的位置

这个命令的一般格式`<C-r>{register}`,`{register}`是要插入的寄存器的名字,使用这种方式很方便能粘贴单词，但如果寄存器中包含大量文本，屏幕会有轻微延迟，因为这种粘贴如同文本是从键盘一一输入的，因此，如果`textwidth`或`autoindent`选项被激活了，可能会出现不必要的换行或缩进;`<C-r><C-p>{register}`更智能，他会按原义插入寄存器内的文本.

<a name="16"></a>

#### 技巧16 随时随地做运算

> 表达式寄存器允许我们做运算，并把结果插入文档

`<C-r>=`访问表达式寄存器，屏幕下方会显示提示符`=`,传给它简单的算术表达式，按`<CR>`,Vim 就会把计算结果输入到光标当前位置.

> 更多表达寄存器的应用在[技巧 71](#71)

#### 技巧17 用字符编码插入非常用字符

> Vim 可以用字符编码功能(Character Code)插入任意字符，使用此功能可以方便的找到键盘上找不到的符号。

只要知道某个字符的编码，就可以让 Vim 插入该字符。

在插入模式中输入`<C-v>{code}`即可，`{code}`是要插入的字符的编码.

**插入非常用字符**

| 操作按键              | 用途                           | 例子 | 按键         |
| --------------------- | ------------------------------ | ---- | ------------ |
| `<C-v>{123}`          | 十进制字符编码插入字符         |      | ``           |
| `<C-v>u{1234}`        | 十六进制编码插入字符           | ¿    | `<C-v>u00bf` |
| `<C-v>{nondigit}`     | 按原义插入非数字字符           | ?    | `<C-v>?`     |
| `<C-k>{char1}{char2}` | 插入二合字母{c1}{c2}表示的字符 | x₃   | `x<C-k>3s`   |

#### 技巧18 用二合字符(digraph)插入非常用字符

> Vim 虽然允许我们用数字编码插入任意字符，不过这难记忆也难输入，我们可以用二合字符(digraph)来插入非常用字符，成对的字符也更容易记忆
> `:digrahs`可以查看二合字母列表，不过该命令输出不好阅读，也可以用`:h digraph-table`查看更有用的输出列表,`:h digraphs-default`对二合字母集的惯例进行了总结。

#### 技巧19 用替换模式替换已有文本

`R`命令由普通模式进入替换模式, 替换模式在文本中以一个字符表示，但屏幕上占据若干列的宽度，此宽度由`tabstop`设置决定,如果在制表符上进入替换模式，那下一个输入的字符会被替换制表符,那该操作就是把 8 个字符替换成了一个字符；针对这种情况，vim 还有另一种替换模式，叫虚拟替换模式(Virtual replace mode)
该模式由`gR`命令触发，它会把制表符当作一组空格处理。

> 也可以设置`set expandtab`选项来让输入的制表符自动转化为空格

`r{char}`命令是单次版本的替换模式以及虚拟替换模式,专用于替换一个字符

### 第四章 可视模式

Vim 由三种不同的可视模式，分别用于操作字符文本，行文本和块文本
也可以用`.`命令重复执行可视模式的命令，然而只在操作面向行的选区时才特别有用。

### 第四章 可视模式

#### 技巧20 深入理解可视模式

> 可视模式允许选中一个文本区域并在其上操作，对于选中的文本，Vim 的视角有异于其他文本编辑器。

很多普通模式命令在可视模式下也能完成相同的功能，`hjkl`仍然是光标键，`f{char}`跳到当前行某个字符上,然后`;`和`,`命令正向反向重复。
每次在可视模式中移动命令，都会改变高亮选取的边界。
某些可视模式命令的基本功能和普通模式相同，但操作上由细微变化。普通模式中是先触发修该命令然后用动作命令指定作用范围；可视模式下是先选中选区，
也就是作用范围，然后在触发修改命令

修改单词:

- 普通模式:`cw`
- 可视模式:`viw`选中单词，`c`执行修改

---

> `<C-g>`能在可视模式以及选择模式之间切换，选择模式类似其他文本编辑器的选择模式(鼠标选中了文本)

---

#### 技巧21 选择高亮选取

> 可视模式的三个子模式用于处理不同类型文本。

**激活可视模式**

| 命令    |           用途           |
| ------- | :----------------------: |
| `v`     |  激活面向字符的可视模式  |
| `V`     | 激活免洗哪个行的可视模式 |
| `<C-v>` |   激活面向块的可视模式   |
| `gv`    |    重选上次的高亮选区    |

**可视模式之间切换**

|   按键操作    |                  用途                  |
| :-----------: | :------------------------------------: |
| `<ESC>/<C-[>` |              回到普通模式              |
|  `v/V/<C-v>`  | 切换到普通模式(在对应的可视模式中使用) |
|      `v`      |        切换到面向字符的可视模式        |
|      `V`      |         切换到面向行的可视模式         |
|    `<C-v>`    |         切换到面向块的可视模式         |
|      `O`      |          切换高亮选区的活动端          |

<a name='22'></a>

#### 技巧22 重复执行面向行的可视命令

> 使用`.`命令重复对高亮选区做修改时,修改会重复作用与相同范围的文本.

要对几行进行相同的缩进操作时,可以用`gv`选中上次选区,但实验过`gv`的操作方式之后,就不建议用了,他是选中上次选中区域在屏幕上的位置,或者说是选中上次选区的位置,上次选中的是文档中第 12 个字符的文本,`gv`就会选中文本中第 12 个字符的文本,不管它是不是你原来选中的字符

> 要执行重复操作时,`.`命令是最好的解决方案,与其在可视模式里选中文本再执行命令,不如直接在普通模式里按`.`

#### 技巧23 只要有可能,最好使用操作符命令,而不是可视命令

当可视命令重复执行时,它只影响相同数量的字符(字符的可视模式),因此对可视模式下的命令执行`.`命令重复,结果可能不会是想要的.因此[技巧 22](#22)
例子:用`vawUj.j.`将下面的三行全部变成大写

```
abc
abcd
abcde
```

结果:

```
ABC
ABCd
ABCde
```

---

> 可视模式下的 U 命令有一个等效的普通模式命令:`gU{motion}`,用这个命令做修改,就可以用点范式完成重复

---

#### 技巧24 用面向列块的可视模式编辑表格数据

```
Chapter            Page
Normal mode          15
Insert mode          31
Visual mode          44
```

要让上面的表变成下面的

```
Chapter      | Page
-------------------
Normal mode  |   15
Insert mode  |   31
Visual mode  |   44
```

- `<C-v>`
- `3j`
- `x...`
- `gv`
- `r|`
- `yyp`
- `Vr-`

#### 技巧25 修改列文本

> 列块可视模式可以同时往若干行中插入文本.

下面的 CSS 代码中图片路径改变了

```
li.one   a{ background-image: url('/images/sprite.png'); }
li.two   a{ background-image: url('/images/sprite.png'); }
li.three a{ background-image: url('/images/sprite.png'); }
```

- `<C-v>jje`
- `c`
- `components`
- `<ESC>`

```
li.one   a{ background-image: url('/components/sprite.png'); }
li.two   a{ background-image: url('/components/sprite.png'); }
li.three a{ background-image: url('/components/sprite.png'); }
```

<a name="26"></a>

#### 技巧26 在长短不一的高亮块后添加文本

> 列块可视模式在操作由行列组成的放行代码是表现的很好,但是,他们并不仅限于操作方形的文本区域.

```
var foo = 1
var bar = 'a'
var foobar = foo + bar
```

- `<C-v>jj$`
- `A;`
- `<ESC>`

```
var foo = 1;
var bar = 'a';
var foobar = foo + bar;
```

> Vim 对于`a`,`i`的约定:
> Vim 对于从普通模式切换到插入模式的约定:`a`和`i`命令都完成此切换,`I`和`A`的表现类似.
> Vim 对从列块可视模式切换到插入模式的命令也遵循类似的约定:`I`和`A`命令都能完成此切换,并将光标置于选区的开头和结尾
> 但在可视模式和操作符待决模式中,`i`和`A`将沿用一个不同的约定,他们会被当作是文本对象的组成部分,选中选区后按`i`不会进入插入模式,但`I`可以.

### 第 5 章 命令行模式

> ed 为 ex 之父,ex 为 vi 之父,vi 为 vim 之父

Vim 的先祖是 Vi,Vi 开创了区分模式的编辑范例.vi 奉行编辑器 ex 为祖先,所以 Vim 有 Ex 命令.

### 第五章 命令行模式

#### 技巧27 认识 Vim 的命令行模式

> 命令行模式会提示输入一条 Ex 命令,一个查找模式或者一个表达式.

按`:`vim 会切换到命令行模式,类似 shell 的命令行,可以输入命令然后按`<CR>`执行.在任何时候都可以按`<ESC>`从命令行模式切换到普通模式.

出于历史原因,命令行模式中执行的命令被称为 Ex 命令. 在按`/`调出查找提示符或用`<C-r>=`访问表达式寄存器时,命令行模式也会激活.

Ex 命令可以读写文件(` :edit``:write `),创建新标签页(`:tabnew`),分割窗口(`:split`),操作参数列表(`:prev`/`:next`),操作缓冲区列表(`:bprev`/`:bnext`)

事实上,Vim 为几乎所有的功能都提供了相应的 Ex 命令(`:help ex-cmd-index`)

**操作缓冲区文本的 Ex 命令**

| Command                                         | Effect                                                                           |
| ----------------------------------------------- | -------------------------------------------------------------------------------- |
| `:[range]delete `                               | [x]Delete specified lines [into register x]t                                     |
| `:[range]yank`                                  | [x]Yank specified lines [into register x]t                                       |
| `:[line]put`                                    | [x]Put the text from register x after the specified linet                        |
| `:[range]copy`                                  | {address}Copy the specified lines to below the line specified by {address}t      |
| `:[range]move `                                 | {address}Move the specified lines to below the line specified by {address}t      |
| `:[range]join`                                  | Join the specified linest                                                        |
| `:[range]normal`                                | {commands}Execute Normal mode {commands} on each specified linet                 |
| `:[range]substitute/{pattern}/{string}/[flags]` | Replace occurrences of {pattern} with {string} oneach specified linet            |
| `:[range]global/{pattern}/[cmd]`                | Execute the Ex command [cmd] on all specified lines where the {pattern} matchest |

Vim 命令行模式中的特殊按键

在命令行模式中,键盘上的大部分按键都是简单的输入一个字符,这和插入模式类似.只不过在插入模式中,文本被输入缓冲区中,命令模式下,文本出现在命令行是国内.另外,这两种模式都可以用组合键触发命令.

有的命令在插入模式和命令行模式可以通用.

`<C-w>`和`<C-u>`分别删除至上一个单词的开头和行首,也可以用`<C-v>`或`<C-k>`来插入键盘上找不到的字符,还可以用`<C-r>{register}`命令把任意寄存器中的内容插入命令行.然而有些命令行模式中的组合键在插入模式中不存在([技巧 33](#33))

命令行模式喜爱,可使用的动作命令数量有限,`<left>`和`<right>`光标键可以一次把光标向左或者向右移动一个字符,习惯了`hjkl`会感到很难受,然而[技巧 34](#34)中展示了 Vim 命令行窗口提供了构造复杂命令所需的完整编辑能力.

Vim 的 Ex 命令的亮点在于操作范围更大.

#### 技巧28 在一行或多个连续行执行命令

> 很多 Ex 命令可以用`[range]`来指定要操作的范围,可以用行号,位置标记或是查找模式来指定范围的开始和结束位置.

`Ex`命令的优点之一就是可以在某一范围内的所有行上执行.

用行号做地址:

- `:1`跳到文本第一行
  - `:1p`跳到第一行并打印第一行的文本
  - `:1d`删除第一行文本
  - `:2G`跳到文本第二行位置(`G`是跳转到指定行,默认是文档末尾)

用地址指定范围:

- `:2,5`跳到文本第 5 行
  - :`2,5p`打印第二到第五行的文本内容,并跳到第五行
  - :`2,5d`删除第二到第五行文本,并跳到文档第二行

用符号做地址:

- `.`代表当前行的地址.
- `$`代表文档末尾的地址
- `%`代笔当前文件的所有行
  - `:%s/Practical/Pragmatic/`把文档中每一行的第一个`Practical`替换成`Pragmatic`

用高亮选区指定范围:

- `2G`跳到第二行
- `VG`选中第二行到文档末的全部内容.
- `:`命令行会预先填充范围`:'<,'>`
- `p`加上预先填充的`:'<,'>`就是`:'<,'>p`打印高亮选中的所有文本

> `'<`代表高亮选区首行的位置标记,`'>`则代表高亮选区的最后一行.这些位置在推出可视模式后仍然存在.

用模式(pattern)指定范围:

`:/<html>/,/<\/html>/`看起来复杂,但还是符合范围的一般形式:`{start},{end}`
`/<html>/`是`{start}`,`/<\/html>/`是`{end}`,这个范围捕获了 html 开标签到闭标签所在行的文本

用偏移地址修正:

`{address}+n`是偏移的一般形式,省略 n 默认 n 为 1,`{address}`可以是符号,地址或模式

`:$-2,$-1p`打印倒数第三行到倒数第二行的文本

**地址符号**

| 符号 | 地址                        |
| ---- | --------------------------- |
| `1`  | 文件第一行                  |
| `$`  | 文件最后一行                |
| `0`  | 虚拟行,位于文件第一行的上方 |
| `.`  | 光标所在行                  |
| `'m` | 包含位置标记 m 的行         |
| `'<` | 高亮选区的起始行            |
| `'>` | 高亮选区的结束行            |
| `%`  | 整个文件(`:1,$`的简写)      |

> 第 0 行不是真是存在,不过在复制或移动文本到文件开头时很有用

> 在定义`[range]`时,它代表连续的行,不过在`:global`命令中可以在非连续行上执行 Ex 命令.

#### 技巧29 用`:t'`和`:m'`命令复制和移动行

> `:copy`命令(简写`:t`)可以把一行或多行从文件的一部分复制到另一部分,`:move`则是移动文本

`copy`命令的格式(`:h :copy`):

`:[range]copy{address}` copy range to address,`:copy`简写`:co`同义词`:t`

> `[range]`可缺省，默认当前行,`{address}`不可缺省

复制第 6 行的数据到当前行

- `:6copy.`
- `6t.`

> `:t.`和`yyp`效果相同，都是创建一个当前行的文本，但是`yyp`会将文本复制到寄存器,而`:t.`不会.

`:move`命令的格式(`:h :move`)，用法类比`:copy`

#### 技巧30 在指定范围内执行普通模式命令

> 想在一系列连续行执行一条普通模式命令，可以用`:normal`命令.结合`.`命令或宏使用，能花费很少努力完成大量重复性工作.

对于[技巧 26](#26)的修改任务，用 Ex 命令方案:

```
var foo = 1
var bar = 'a'
var foobar = foo + bar
```

- `A;<ESC>`将第一行最后添加`;`
- `jVG`选中剩下的行
- `:'<,'>normal .`将剩下的行末尾添加`;`

> `:normal`后面接的操作就是模拟在 Normal 模式下的输入

- 注释整个 js 文件:
  - `:%normal i//`
- 为整个文件每行末尾添加`;`:
  - `:%normal A;`

#### 技巧31 重复上次的 Ex 命令

> `.`命令可以重复上次的普通模式命令。
> 相应的 Ex 命令也可以重复，使用`@:`(`:h @:`)
> `@`执行寄存器命令(`:h @`),`:`寄存器总是保存上次执行的 Ex 命令
> `@@`则是重复上一个`@`命令
> `<C-o>`命令能回到跳转列表的上次跳转。跳转和移动光标不一样的`1G`这叫跳转到第一行，用`j`移动光标到第一行不叫跳转

#### 技巧32 自动补全 Ex 命令

- `<C-d>`显示可用的补全列表
- `<Tab>`遍历可用的补全列表
- `<S-Tab>`反向遍历

> 更多查阅`:h :command-complete`

`wildmode`选项可以自定义补全行为(`:h 'wildmode'`)
`wildmenu`选项启用会在补全时提供一个导航列表

#### 技巧33 把当前单词插入命令行

> 即使在命令行模式下，Vim 也知道光标的位置

Vim 命令行模式下， `<C-r><C-w>`会把光标下的单词插入到命令行中,详情查阅`:help c_CTRL-R_CTRL-W`或`:help c_<C-R>_<C-W>`

```vim
set width
```

光标移到`width`上面，`:help`然后进入命令行模式，`<C-R><C-W>`按下<kbd>CTRL</kbd><kbd>w</kbd>,再回车就能很快查找选项的帮助文档.

<a name="34"></a>

#### 技巧34 回溯历史命令

> Vim 会记录命令行模式中执行过的命令，并提供了方向键回滚和命令行窗口两种方式查看先前的命令.
> vim 默认记录 50 条历史命令.`history`选项值可以改变上限,命令历史在重启 Vim 后仍保存。

##### 命令行窗口

`q:`进入命令行窗口。`:help cmdwin`查看详细信息,`:q`直退出该窗口，`<CR>`执行光标所在行的命令，并退出命令行窗口.

命令行窗口每一行文本代表一条执行过的命令，可以像普通文本一样编辑

已经在命令行模式下编辑命令，但发现需要更复杂的编辑能力来编辑命令，可以`<C-f>`切换到命令行窗口，正在编辑的命令会保留，可以继续编辑。

**打开命令行窗口的方式**

| 命令    | 动作                         |
| :------ | :--------------------------- |
| `q/`    | 打开查找命令历史的命令行窗口 |
| `q:`    | 打开 Ex 命令历史的命令行窗口 |
| `<C-f>` | 从命令行模式切换到命令行窗口 |

#### 技巧35 运行 Shell 命令

> Vim 可以调用外部程序，也可以把缓冲区的内容作为标准输出发送给外部程序，或把外部命令的输出导入到缓冲区.

Vim 的命令模式中,给命令加一个感叹号`!`就可以调用外部程序

查看当前目录:
`:! ls`

查看缓冲区列表内容:
`:ls`(Vim 内置命令)

Vim 命令行中,`%`表示当前文件名(`:h cmdline-special`)

`:!python %` 执行当前编辑的 python 文件

`:!{cmd}`用于执行一次性的命令,如果要在 shell 中执行几条命令可以用`:shell`启动交互的 shell 会话(`:h :shell`),`exit`可以退出 shell 返回 vim。
在终端运行 Vim 时，可以用<kbd>Ctrl</kbd><kbd>z</kbd>挂起作业，将 Vim 移到后台,`fg`命令可以唤起被挂起的作业，`jobs`查看作业列表。

缓冲区内容作为标准输入和输出：

`:read !{cmd}`将 cmd 的输出读取到当前缓冲区，`:write !{cmd}`将缓冲区内容作为`{cmd}`的标准输入.

`:read !ls`将当前文件目录列表输入到缓冲区,`:write !sh`将缓冲区每一行作为输入传入`sh`就是执行缓冲区每一行.

**还可以用外部命令过滤缓冲区的内容**

当指定范围时，`:!{cmd}`就有了不同的含义，由`[range]`指定的范围会传给`{cmd}`作为标准输入，然后又会用`{cmd}`的输出覆盖原来`[range]`内的内容。

```csv
first name,last name,email
john,smith,john@example.com
drew,neil,drew@vimcasts.org
jane,doe,jane@example.com
```

`:2,$!sort -t',' -k2`按逗号分列，并按照第二列排序:

```csv
first name,last name,email
jane,doe,jane@example.com
drew,neil,drew@vimcasts.org
john,smith,john@example.com
```

Vim 提供一种方便的快捷方式设置`:[range]!{filter}`中的`[range]`，可用`!{motion}`来切换到命令行模式，并把指定`{motion}`涵盖的范围预置在命令行中

一些调用外部命令的方式：
| 命令                   | 用途                                                |
|------------------------|-----------------------------------------------------|
| `:shell`               | 启动一个 shell                                      |
| `:!{cmd}`              | 在 shell 中执行`{cmd}`                              |
| `:read !{cmd}`         | 在 shell 中执行`{cmd}`,并把其标准输出插入到光标下方 |
| `:[range]write !{cmd}` | 在 shell 中执行`{cmd}`,并以`[range]`作为其标准输入  |
| `:[range]!{filter}`    | 使用外部命令`{filter}`过滤指定的`[range]`           |

#### 技巧36 批处理运行 Ex 命令

当需要执行多条 Ex 命令完成任务时，可以一条一条的`:{cmd}`来执行，也可以将所有 Ex 命令存成一个脚本文件，如`quote.vim`(.vim 扩展名是为了使 Vim 显示正确语法高亮)  
当存成脚本文件时，文件每一行代表一条 Ex 命令，而且不用加`:`

`quote.vim`:

```vim

" 将从浏览器复制的键值对复制到{}中后执行命令
" 范围是从{ 到  }
"/{/;/}/ s/\(\<.*\>\):\s\(.*\)$/'\1':'\2',/

" 改进
?{?,/}/ s/\(\<.*\>\):\s\(.*\)$/'\1':'\2',/g
" Format

```

在将浏览器请求头信息复制到 Vim 中时，需要将其转换为字典，就要在键值对的字段上加引号,上面的脚本在每次复制过来之后就执行，可以批量添加引号和逗号。
`Format`时 Coc-nvim 的命令，没有安装可注释掉

```python
data = {
'on':'true',
'page':'1',
'pageSize':'15',
'productName':'',
'conditionType':'1',
'applyname':'',
'applysn':'',
}
```

当光标处于`{}`之间，并将 Post 请求的请求信息粘贴过来后，就可以执行`quote.vim`脚本.

##### 用脚本修改多个文件

如果脚本只执行一次，那么 ex 命令存成脚本没有多大意义，只有多次运行一组 Ex 命令或该命令会多次使用，存成脚本才有意义。

需要一次对多个文件进行相同修改，可以使用`:args`命令，当 vim 同时打开多个文件时，所有文件会被加入 Vim 的参数列表中，`args`
可以查看列表里有那些文件.

`[range]argdo[!] {cmd}`可以对列表里的多个文件执行命令(`!`执行外部命令)

## 第二部分 文件

> 这部分讲述如何使用文件和缓冲区。

Vim 允许一个编辑会华中编辑多个文件，即可以每次显示一个文件，也可以把工作区分成若干窗口或标签页，每个窗口(标签页)包含独立的缓冲区。

### 第六章 管理多个文件

#### 技巧37 用缓冲区列表管理打开的文件

##### 文件和缓冲区的区别

文件是存储在磁盘上的，而缓冲区是存储在内存中的，vim 打开一个文件，该文件的内容就被读入到缓冲区中，所以刚开始编辑时，文件和缓冲区内容相同，对缓冲区做出修改后，二者就会有差别，对缓冲区进行保存时，Vim 会把缓冲区内容写入到文件中，绝大对数 Vim 命令都用来操作缓冲区，也有一些命令针对文件进行操作，例如:`:write`、`:read`和`:saveas`

##### 缓冲区列表

vim 能同时在多个缓冲区工作。

`vim *.txt`会打开所有`.txt`文件，vim 启动时显示的窗口是第一个文件，虽然其他的文件不可见，但是内容已经在后台的缓冲区了，`:ls`vim 内部命令会显示所有载入内存的缓冲区列表。`:bnext`切换到下一个缓冲区,`<C-^>`快捷键(按`<Ctrl>`+`6`).

- `:bnext` 正向遍历缓冲区列表
- `:bprev` 反向遍历缓冲区列表
- `:bfirst` 跳到列表开头
- `:blast` 跳到列表结尾

`:bufdo`命令允许在`:ls`列出的所有缓冲区列表上执行`EX`命令,实际上`:argdo`更实用

##### 删除缓冲区

`bd[elete][!] {bufname}`按名字删除 或 `:bd[elete][!] [N]`按编号删除(`:ls`会显示编号),如果缓冲区未保存，`[!]`选项慎用,它会不管缓冲区的修改是否保存，直接删除缓冲区，会丢失所有未保存的修改。

删除缓冲区不会影响到缓冲区关联的文件。缓冲区不是编辑多个文件时的最佳选择，最好是将工作区划分多个分割窗口、标签页或者使用参数列表。

#### 技巧38 用参数列表将缓冲区分组

> 参数列表记录在启动时作为参数传递给 Vim 的文件列表。

`:args {arglist}`

`{arglist}` 可以包含文件名、通配符甚至是 shell 命令的输出

- `:args` 列出参数列表的所有文件
- `:args 1.txt 2.txt`将两个文件添加到参数列表
- `:[range]argdo[!] {cmd}` 对所有参数列表中的文件执行`{cmd}`命令

`:next`或`:prev`命令遍历参数列表中的文件

#### 技巧39 管理隐藏缓冲区

> Vim 对修改过的缓冲区特殊对待，防止未保存就意外退出。

```
:ls
  1  h   "~/vimwiki/index.md"           line 16
  2 #h   "~/vimwiki/Books_Notes.md"     line 1
  3 %a + "~/vimwiki/vim实用技巧.md"     line 877

```

有多个缓冲区时，当前窗口显示的缓冲区是`a` active 的，`%`表示当前缓冲区,其他的都是`h` hidden(也就是隐藏缓冲区),当隐藏缓冲区有未保存的修改时,会被设置`+`

退出时处理隐藏缓冲区的方式:

| 命令       | 用途                                     |
| ---------- | ---------------------------------------- |
| `:w[rite]` | 把缓冲区内容写入磁盘                     |
| `:e[dit]!` | 把磁盘文件内容读入缓冲区(即回滚所做修改) |
| `:qa[ll]!` | 关闭所有窗口，摒弃修改且不警告           |
| `:wa[ll]!` | 把所有改变的缓冲区写入磁盘               |

##### 设置`hidden`

默认情况下，有缓冲区修改未保存时，切换缓冲区 vim 会有错误提示，并不允许切换缓冲区,可以用`:next!`强制切换，但当使用`:agrdo`、`:bufdo`等批量操作时，也会提示错误，所以要设置`hidden`选项，设置后可以不经保存就切换缓冲区，可以用`:next`切换未保存的缓冲区.

启用`hidden`后，可以用一条`argdo {cmd}`修改所有缓冲区文件，然后再用`:first`切换到第一个缓冲区 用`:wn`逐个保存(可以注意检查每个缓冲区),或者`:wa`保存所有缓冲区

#### 技巧40 将工作区分成窗口

`:split` 将创建一个竖直的分割窗口,`:vsplit`将创建垂直的分割窗口

##### 创建分割窗口

`<C-w>s`命令水平切分窗口，`<C-w>v`命令垂直切分窗口

每次执行完 `<C-w>s` 和`<C-w>v`之后，新生成的两个窗口会显示原窗口相同的缓冲区.两个窗口显示相同的缓冲区在编辑长文件时很有用，可以滚动一个窗口，修改另一个窗口.

`:edit {filename}`会把缓冲区载入当前的活动窗口，先执行`<C-w>s`再执行`:edit {filename}`会把文件载入新的窗口.

`:split {filename}`命令将上面的操作合并，会水平打开新窗口，并将`{filename}`载入缓冲区。

**切分窗口的方式**

| 命令                   | 用途                                         |
| ---------------------- | -------------------------------------------- |
| `<C-w>s`               | 水平切分当前窗口，新窗口显示当前缓冲区       |
| `<C-w>v`               | 垂直切分当前窗口，新窗口显示当前缓冲区       |
| `:sp[lit] {filename}`  | 水平切分当前窗口，并在新窗口中载入`filename` |
| `:vsp[lit] {filename}` | 垂直切分当前窗口，并在新窗口中载入`filename` |

**窗口间切换**

| 命令     | 用途           |
| :------- | :------------- |
| `<C-w>w` | 窗口间循环切换 |
| `<C-w>h` | 切换到左边窗口 |
| `<C-w>j` | 切换到下边窗口 |
| `<C-w>k` | 切换到上边窗口 |
| `<C-w>l` | 切换到右边窗口 |

##### 关闭窗口

`:close`命令关闭活动窗口.

`:only`命令关闭除了活动窗口外的所有其他窗口

| Ex 命令    | 普通模式命令 | 用途                            |
| ---------- | ------------ | ------------------------------- |
| `:clo[se]` | `<C-w>c`     | 关闭活动窗口                    |
| `:on[ly]`  | `<C-w>o`     | 只保留活动窗口,关闭其他所有窗口 |

**改变窗口**

| 命令         | 用途                        |
| ------------ | --------------------------- |
| `<C-w>=`     | 使所有窗口等宽、等高        |
| `<C-w>_`     | 最大化活动窗口高度          |
| `<C-w>｜`    | 最大化活动窗口宽度          |
| `[N]<C-w>_`  | 把活动窗口高度设置为`[N]`行 |
| `[N]<C-w>｜` | 把活动窗口高度设置为`[N]`列 |

#### 技巧41 用标签页将窗口分组

vim 中,标签页是可以容纳一系列窗口的容器`:h tabpage`

Vim 标签页把工作分隔到不同的工作区。

`:lcd {path}`可以设置当前窗口的本地工作目录，`:lcd`只影响当前窗口，而非当前标签页。
一个标签页设置多个窗口，可以有多个不同的工作目录。可以用`:windo lcd {path}`为当前标签页所有窗口设置工作目录。

##### 打开及关闭标签页

`:tabedit {filename}`命令可以打开一个新的标签页,省略`{filename}`，Vim 会创建一个新的标签页，包含空的缓冲区

`<C-w>T`命令可以把当前窗口移动到一个新的标签页面中(`:h CTRL-W_T`)

| 命令                    | 用途                                 |
| ----------------------- | ------------------------------------ |
| `:tabe[dit] {filename}` | 新标签页中打开文件                   |
| `<C-w>T`                | 当前窗口移动到新的标签页             |
| `:tabc[lose]`           | 关闭当前标签页及其中的所有窗口       |
| `:tabo[nly]`            | 只保留活动标签页，关闭所有其他标签页 |

##### 在标签页间切换

标签页的编号从 1 开始，可以用`[N]gt`在标签页间切换，省略`N`会跳到下一个标签页,`gT`反向跳转

| Ex 命令          | 普通模式命令 | 用途                      |
| ---------------- | ------------ | ------------------------- |
| `:tabn[ext] {N}` | `{N}gt`      | 切换到编号为`{N}`的标签页 |
| `:tabn[ext]`     | `gt`         | 切换到下一标签页          |
| `:tabp[revious]` | `gT`         | 切换到上一标签页          |

##### 重拍标签页

`:tabmove[N]`可以重新排列标签页. `[N]`为 0 时，当前标签页会被移到开头，省略`[N]`,当前标签页会被移动到结尾。

### 第七章 打开及保存文件

#### 技巧42

> `:edit`命令允许通过文件的绝对和相对路径来打开文件。也可以指定一个相对于活动缓冲区的路径

`:pwd`命令打印当前工作目录.

`:edit {file}`命令接受相对于工作目录的文件路径，也接受绝对路径

`:edit %<TAB>`

`%`符号代表活动缓冲区的完整文件路径`:h cmdline-specal`,`<TAB>`会将其展开，使之称为活动缓冲区的完整文件路径。

`:edit %:h<TAB>`

`:h`修饰符会去除文件名，但保留路径中的其他部分。`%:h<TAB>`会被展开为当前文件所在目录的路径

```
"命令提示符输入%%自动展开为缓冲区所在目录的路径
cnoremap <expr>%% getcmdtype()==':'?expand('%:h').'/':'%%'
```

#### 技巧43 使用`:find`打开文件

> `find`命令允许通过文件名打开一个文件，但无需输入完整文件路径。想要使用此功能，需要先配置`path`选项。
> 设置`path`参见`:h file-searching`

`rails.vim`插件能自动配置`path`，

```
" https://github.com/tpope/vim-rails
Plug 'tpope/vim-rails'

```

#### 技巧44 netrw 管理文件系统

> Vim 发行版自带 netrw 插件允许对文件进行管理.netrw 插件提供`:Explore`打开文件所在目录

| Ex 命令    | 缩写 | 用途                                     |
| ---------- | ---- | ---------------------------------------- |
| `:edit`    | `:e` | 打开文件管理器，显示当前工作目录         |
| `:Explore` | `:E` | 打开文件管理器，并显示活动缓冲区所在目录 |

`Sexplore`,`Vexplore`在水平和垂直方向切分窗口打开文件管理器.

#### 技巧45 把文件保存到不存在的目录中

> 缓冲区路径包含不存在的目录，vim 仍然允许编辑，但是保存时报错。

`:edit {file}`一般用于打开已存在的文件，如果指定了一个不存在的路径，vim 会创建新的空白缓冲区。
`<C-g>`会显示当前缓冲区文件名及状态，此时会显示新文件

这种情况下保存报错的措施:调用外部命令 mkdir

`!mkdir -p %:h`

#### 技巧46 超级用户权限保存文件

> 可以用超级用户运行 Vim,但有时候不得不把修改保存到一个需要 sudo 权限的文件。无需重启 VIM 可以实现这一功能，可以把任务委托给 sudo 运行的 shell 进程.

修改`/etc/hosts`

`vim /etc/hosts`

```
:w
E45: 'readonly' option is set (add ! to override)
```

显示文件只读，`:w!`强制写文件，又会提示没有权限

`:w !sudo tee % > /dev/null`

`:w[rite] !{cmd}`会把缓冲区的内容作为标准输入传给指定`{cmd}`，`{cmd}`可以是任意外部程序(`:h :write_c`)

`tee` 程序将以 sudo 权限运行，也就是拥有写入文件的权限

`tee /etc/hosts > /dev/null`会将缓冲区内容当作标准输入，用来覆盖 hosts 文件内容.

## 第三部分

> 更快速的移动及跳转

### 第八章 用动作命令在文档中移动

#### 技巧47 让手指保持在本位行(HOME ROW)上

> VIM 针对盲打人员进行了优化，因此，只有学会让手指不离开本位行就可以移动光标，才能更快操作 VIM.

QWERTY 键盘的本位行：左 a,s,d,f 右 j,k,l,;

> 戒掉光标键

```
nnoremap <UP> <Nop>
nnoremap <DOWN> <Nop>
nnoremap <LEFT> <Nop>
nnoremap <RIGHT> <Nop>
```

#### 技巧48 区分实际行与屏幕行

> 当`wrap`设置被启用时，每个超出窗口宽度的文本行都会被回绕显示，以保证所有文本都能显示出来。这样，文本的一行会被显示为屏幕上的多行.
> 当设置`number`后，会显示每一行行号，行号对应的是实际行，它会占据屏幕的一行或几行(文本回绕时),回绕显示的行没有行号，因为它是屏幕行(虚拟行)

| 命令行 | 光标动作                       |
| ------ | ------------------------------ |
| `j`    | 向下移动一个实际行             |
| `gj`   | 向下移动一个屏幕行             |
| `k`    | 向上移动一个实际行             |
| `gk`   | 向上移动一个屏幕行             |
| `0`    | 移动号实际行的行首             |
| `g0`   | 移动到屏幕行的行首             |
| `^`    | 移动到实际行的第一个非空白字符 |
| `g^`   | 移动到屏幕行的第一个非空白字符 |
| `$`    | 移动到实际行的行尾             |
| `g$`   | 移动到屏幕行的行尾             |

```vim
" j/k will move virtual lines (lines that wrap)
noremap <silent> <expr> j (v:count == 0 ? 'gj' : 'j')
noremap <silent> <expr> k (v:count == 0 ? 'gk' : 'k')
```

上面的设置将`jk`设置为默认移动屏幕行(虚拟行),加上`[count]`后移动实际行。`2j`向上移动 2 个实际行。

#### 技巧49 基于单词移动

> Vim 有两组面向单词正向反向移动的命令。

| 命令 | 光标移动 |
| `w` | 正向移动到下一个单词开头 |
| `b` | 反向移动到当前单词/上一单词开头 |
| `e` | 正向移动到当前单词/下一单词结尾 |
| `ge` | 正向移动到上一单词的结尾 |

> Vim 认为单词是由字母、数字、下划线或其他非空白字符的序列组成，单词间以空白字符分隔(`:h word`)

Vim 也有基于字符串的命令(`:h WORD`)。基于字符串的命令与基于单词的命令向对应:`W,B,E,gE`.VIM 认为只有用空白字符隔开的才是字符串

#### 技巧50 对字符进行查找

`f{char}`命令是 Vim 中移动最快的方式之一(`:h f`)。它会在光标位置和当前行行尾之间查找`{char}`字符，未找到则光标不动

`;`重复上一次`f`命令，`,`反向重复上次的字符查找命令

**字符查找命令**

| 命令      | 用途                                         |
| --------- | -------------------------------------------- |
| `f{char}` | 正向移动到下一个`{char}`所在之处             |
| `F{char}` | 反向移动到上一个`{char}`所在之处             |
| `t{char}` | 正向移动到上一个`{char}`所在之处的前一个字符 |
| `T{char}` | 反向移动到上一个`{char}`所在之处的后一个字符 |
| `;`       | 重复上次的字符查找                           |
| `,`       | 反向查找上次的字符查找命令                   |

为什么会需要两种字符查找命令呢?

例子:删除下面的`Mister Bond`
`I've benn expecting you, Mister Bond.`

`f,`找到`,`并将光标移到`,`处

`dt.`删除从光标当前位置到`.`前面的所有字符

#### 通过查找进行移动

字符查找命令`f{char}`等执行起来很方便，但是局限于当前行，且只能查找一个字符.

如果想查找一个以上的字符或是移动到当前行之外，就需要用到查找命令.

`/{pattern}[/]<CR>` `pattern`可以是简单字符/字符串或者是正则表达式

`n`重复上一次查找命令,`N`反向查找

`?`是向上查找命令，其他和`/`一样.

##### 用查找操作文本

```
This phrase takes times but eventually gets to the point.
```

光标移动到`takes`的`t`处，执行`d/ge<CR>`，将会删除从 takes 到`ge[t]`的所有字符.

#### 技巧52 用精确的文本对象选择选区

> 文本对象允许操作括号，被引用的文本，XML 标签以及其他文本中的常见结构.(`:h text-objects`)

```
val tpl = [
  '<a href="{url}">{title}</a>'
]
```

Vim 文本对象由两个字符组成，第一个字符永远是`i`或`a`，`i`开头的文本对象选择分隔符内部的文本，`a`开头的文本对象选择包括分隔符在内的整个文本.

> `i` for inside, `a` for around/all

| Text Object | Selection                    |
| :---------- | :--------------------------- |
| `a)`or `ab` | A pair of (parentheses)      |
| `a}`or `aB` | A pair of {braces}           |
| `a]`        | A pair of [brackets]         |
| `a>`        | A pair of <angle brackets>   |
| `a'`        | A pair of 'single quotes'    |
| `a"`        | A pair of "double quotes"    |
| `at`        | A pair of <xml>tags</xml>    |
| `a`\`       | A pair of \`backticks\`      |
| `i)`        | or ibInside of (parentheses) |
| `i}`        | or iBInside of {braces}      |
| `i]`        | Inside of [brackets]         |
| `i>`        | Inside of <angle brackets>   |
| `i'`        | Inside of 'single quotes'    |
| `i"`        | Inside of "double quotes"    |
| `i`\`       | Inside of `backticks`        |
| `it`        | Inside of <xml>tags</xml>    |

##### 用文本对象执行操作

可视模式可以看到文本对象选择了哪些内容，但只有操作符待决模式中使用文本对象，才是其强大能力的展现。

> 在命令语法看到`{motion}`时，也可以在这里使用文本对象，常见的有`d{motion}`、`c{motion}`和`y{motion}`.

`ci"`会修改双引号内部的内容,`yit`会复制标签内的文本，`dit`会删除标签内的文本.

#### 技巧53 删除周边，修改内部

> 文本对象通常是成对出现的，一个用于操作内部对象的文本，一个则操作对象周围的文本，这一节介绍文本对象的典型用法。
> Vim 将文本对象分为块对象和非块对象,无助于理解.可以理解为分隔符文本对象(由配对符号作为开始和结束)和范围文本对象(以单词句子和段落为文本结构的范围界定)

范围文本对象

| 文本对象 | 选择范围             |
| :------- | :------------------- |
| `iw`     | 当前单词             |
| `aw`     | 当前单词以及一个空格 |
| `iW`     | 当前字符串           |
| `aW`     | 当前字符串及一个空格 |
| `is`     | 当前句子             |
| `as`     | 当前句子及一个空格   |
| `ip`     | 当前段落             |
| `ap`     | 当前段落及一个空行   |

#### 技巧54 设置位置标记，以便快速跳回

> Vim 的位置标记允许快速跳到文档中感兴趣的地方。可以手动设置标记，不过 VIM 也会自动记录某些感兴趣的位置点

##### 设置标记(mark)

`m{a-zA-Z}`命令会用选定的字母标记当前光标所在位置。`:h m`

`{a-z}`位置标记只在每个缓冲区局部可见。

`{A-Z}`位置标记在全局可见。

> Vim 不会用可见标识显示标记的位置。只要确定设置好了，就可以跳转.

##### 标记跳转

VIM 提供两条普通模式命令，用来跳转到位置标记。(`:h mark-motions`)

`'{mark}`命令跳转到标记位置的所在行，光标位于该行的第一个空白字符上；

\`{mark} 命令把光标移到设置该位置标记时的光标所在之处。

##### 自动位置标记

每个缓冲区最多可以设置 26 个小写位置标记，这可能远比实际需要的多。
之所以这样，是因为 Vim 前身 Vi 里，没有可视模式这样的功能，那时，标记功能重要得多。
但现在很多需要标记完成的工作，可以用 VIM 可视模式来做，因此位置标记相应减少了。

位置标记在 VIM 里没有 过时，特别是 VIM 会自动设置一些位置标记，这些标记用起来很方便.

**VIM 的自动位置标记**

| 位置标记 | 跳转                             |
| -------- | -------------------------------- |
| \`\`     | 当前文件中上次跳转动作之前的位置 |
| \`.      | 上次修改的位置                   |
| \`^      | 上次插入的位置                   |
| \`[      | 上次修改或复制的起始位置         |
| \`]      | 上次修改或复制的结束位置         |
| \`<      | 上次高亮选区的起始位置           |
| \`>      | 上次高亮选区的结束位置           |

\`\` 是对跳转列表的补充(参见[技巧 56](#56h)),
\`. 标记是对改变列表的补充([技巧 57](#57))

#### 技巧55 在匹配括号间跳转

> VIM 提供一个动作名林，可以在开闭括号间跳转，激活`matchit.vim`插件后，也可以在成对<XML>标签以及某些编程语言的关键字上跳转。

`%`命令允许在一组开、闭括号间跳转(`:h %`),可用于`()`、`{}`、`[]`

想把`{}`替换成`[]`：
`cities = {London Berlin New\ York}`

`%`跳转到`}`处，再按`%`跳转到`{`处,`r[`替换`{`,\`\`跳转到上一次跳转位置`}`,`r]`替换.

这里的\`\`跳转也可以用`<C-o>`完成。

> 另外有[`surround.vim`](https://github.com/tpope/vim-surround)插件提供更多命令完成上面修改括号的工作.

##### 在配对的关键字间跳转

VIM 发布时带了一个`matchit`插件，增强`%`命令的功能。使`%`可以在配对的关键字间跳转。如 HTML 文件的开闭标签。

`matchit`插件缺省并未使用。

```
set nocompatible
filetype plugin on
packadd! matchit
```

> Surround.vim:(vim-plug)
>
> ```
> call plug#begin('~/.vim/plugged')
> Plug 'tpope/vim-surround'
> call plug#end()
> ```

```
New York
```

`vee`选中`New York`,`S"`用双引号将选中文本扩起来

### ┆ 第九章 在文件间跳转

#### 技巧56 遍历跳转列表

> Vim 会记录跳转前后的位置，并提供一些命令让我们能原路返回.

类似网页浏览的上一页和下一页，VIMd 的跳转:`<C-o>`后退，`<C-i>`前进

`:jumps`查看跳转列表，类似浏览器的历史记录

> 大范围的动作命令是跳转，小范围的动作命令是移动

**常见跳转命令**

| 命令                                  | 用途                            |
| ------------------------------------- | ------------------------------- |
| `[count]G`                            | 跳转到指定行号                  |
| `/pattern<CR>`/`?pattern<CR>`/`n`/`N` | 跳转到上一个/下一个模式出现之处 |
| `%`                                   | 跳转到匹配的括号之处            |
| `(`/`)`                               | 跳转到上一句/下一句的开头       |
| `{`/`}`                               | 跳转到上一段/下一段的开头       |
| `H`/`M`/`L`                           | 跳到屏幕最上方/正中间/最下方    |
| `gf`                                  | 跳到光标下的文件名              |
| `<C-]>`                               | 跳到光标下关键字的定义之处      |
| \`{mark}/\'{mark}                     | 跳转到一个位置标记              |

`<C-o>`和`<C-i>`本身不会被当作动作命令,也就是说他们的跳转不会影响到跳转列表

Vim 可以同时维护多份跳转列表，实际上，每个单独的窗口都拥有一份自己的跳转列表，如果在使用分割窗口或标签页，`<C-o>`和`<C-i>`命令始终在当前活动窗口的跳转列表内进行跳转。

> VIM 把`<C-i>`和`<TAB>`当作一个东西，当重新映射`<TAB>`时，也重新映射了`<C-i>`，如果重新映射了`<TAB>`，那`<C-i>`的行为也会随之改变，不再是默认的跳转列表了。

#### 遍历改变列表

> 对文档做出修改后，VIM 会记录当时光标所在的位置，遍历改变列表的方法很简单.这可能是跳转到要去的地方的最快方式.

VIM 会在编辑会话期间维护一张表，里面记载对每个缓冲区做的修改。

`:changes`可以查看改变列表。

`g;`和`g,`分别正向和反向遍历改变列表。用法参考`f{char}`的`;`和`,`命令

VIM 会自动创建一些位置标记，他们是对改变列表的补充。
`.`标记是上次修改的位置。`^`标记是上次退出插入模式时光标所在位置。

#### 技巧58 跳到光标下的文件

> VIM 会把文档中的文件名当成一个超链接，正确配置后，可以用`gf`命令跳转到光标下的文件。

##### 指定文件的扩展名

`suffixesadd`选项允许指定一个或多个文件扩展名，当 VIM 用`gf`命令搜寻文件名时，会尝试使用这些扩展名。`:h "suffixesadd"`

##### 指定搜寻的目录

使用`gf`时，VIM 会检查`path`目录列表的每个目录。`path`设置也会用于`:find`命令.

`:set path?`查看`path`的值,`.`表示当前文件所在目录，空格表示工作目录.

> `<C-]>`命令作用类似，也需要进行一些配置([技巧 103][#103]),使用实例在[技巧 104](#104)

#### 技巧59 用全局位置标记在文件间快速跳转

> 全局位置标记是一种书签，让我们可以在文件间跳转，全局标记在我们分析完代码，并想快速跳回一个文件时特有用.

`:vimgrep /pattern/[j][g] {file}`命令可以在文件中查找。默认情况下，`:vimgrep`会跳转到它的第一处匹配，这可能会切换到另一个文件，如果只有一两个匹配，`<C-o>`就可以跳转了，但如果几十处匹配的地方，找到了目标条目后再用`<C-o>`就很麻烦了。
所以在查找之前先设置全局位置标记`mM`然后就可以用\`M 跳回了

使用下面的相关命令一般要养成设置全局标记的习惯

- quickfix 命令：`:grep`、`:vimgrep`、`:make`
- 缓冲区列表相关或参数列表相关命令:`:args {arglist}`、`:agrdo`

## 第四部分 寄存器

Vim 的寄存器是用于保存文本的简单容器,它们可以想剪贴板一样复制粘贴文本，也可以记录一系列按键操作，录制为宏。

`:reg[ister] ["{register}]`能查看所有寄存器或查看指定寄存器内容.

### 第十章 复制与粘贴

VIM 的剪切、复制和粘贴操作在功能上 有别于其他编辑器，术语也不同，删除(delete)、复制(yank)与粘贴(put).

#### 技巧60 用无名寄存器实现删除、复制和粘贴操作

在其他编辑器上，复制、剪切和粘贴的操作都指的是操作系统剪切板。在 VIM 里，操作的是寄存器，而不是剪切板。

##### 无名寄存器

> 翻译是无名寄存器(unnamed register)

`x`、`s`、`d`、`c`、`y`命令以及对应的大写命令，都会将操作的文本覆盖到无名寄存器中。

`p` put 命令默认会将无名寄存器中的内容复制到光标之后

```
2) line two
1) line one
```

光标移动到第一行，`dd`删除第一行并放置到无名寄存器中，`p`将刚刚删除的内容复制到下一行，完成两行内容互换。

```
collection = getCollection();
process(someThingInTheWay , target);
```

想将上面的 collection 替换 someThingInTheWay .
`yaw`复制 collection,`daw`删除 somethingintheway ,在`p`粘贴，发现并没有达到目的，这是因为`daw`的操作将文本覆盖到无名寄存器中了。

#### 技巧61 深入理解 VIM 寄存器

> VIM 不适用单一的剪贴板进行操作，而是为这些操作提供了一系列的寄存器，使用复制粘贴等操作时可以指定使用哪一个寄存器进行操作。

##### 引用一个寄存器

> VIM 的删除文本的操作会将文本复制到寄存器中，然后再删除文本。而`_`寄存器是特殊寄存器，进入其中的文本不会被保存，也就是真正的"删除"操作。

通过给命令加`"{register}`前缀的方式，可以指定使用的寄存器。

- `"ayaw`将会把复制的单词复制到寄存器 a 中。
- `"bdd`会把删除的行复制到寄存器 b 中
- `"ap`把寄存器 a 中的内容粘贴出来

除了普通模式的命令，VIM 也提供对应的 Ex 命令。

- `:delete c`将当前行剪切到寄存器 c
- `:put c`将寄存器 c 内容粘贴到当前所在行之下。

虽然 EX 命令繁琐，但和其他 ex 命令结合，或用于脚本编程,会更方便。

###### 无名寄存器`"`

不管是否指定使用寄存器，无名寄存器`"`总是会默认使用。
`0dd`会将当前行删除，并将内容复制到寄存器 0，同时，`"`的内容也会变成当前当内容。

所以无名寄存器的内容很容易被覆盖，不小心就会出错。

###### 复制专用寄存器`0`

当使用`y{motion}`时，被复制的文本不仅会被拷贝到无名寄存器中，也会被拷贝到复制专用的寄存器`0`中

复制寄存器只有使用`y[ank]`命令才会被赋值，所以比无名寄存器稳定。

```
collection = getCollection();
process(someThingInTheWay , target);
```

`yaw`复制`collection`,`daw`删除`something.....`,`"0p`将`collection`从`0`寄存器中复制出来

###### 有名寄存器(`"a-"z`)

VIM 提供了一组以 26 个英文字母命名的有名寄存器，这意味着可以剪切多达 26 段文本。用小写字母引用的有名寄存器，会覆盖寄存器的原有内容，而用大写字母的，则会将新内容添加到原有内容之后。参考[技巧 100](#100)

`"add`将当前行复制到寄存器`a`，并删除当前行。
`"Add`会将当前行添加到寄存器`a`原来的内容后面，并删除当前行。

###### 黑洞寄存器

黑洞寄存器`_`是有去无回的，用`"_`来引用.
复制进入黑洞寄存器的内容会被彻底删除.

一般来讲，不管什么命令是否指定了寄存器，默认的未命名寄存器都会被使用.

- 使用`y`命令，复制的文本会进入`"`寄存器、`"0`寄存器(复制专用)和指定使用的寄存器(如果有的话).
- 使用`d`命令，删除的文本会进入`"`寄存器、`1-9`号寄存器和指定使用的寄存器

但是一旦指定使用的寄存器是`_`黑洞寄存器，那么该动作操作的文本就不会进入其他任何一个寄存器，而是进入黑洞寄存器，因为黑洞寄存器又不存放任何文本，所以在删除某文本而不想保留副本时很有用。但是复制文本的操作使用黑洞寄存器就没有意义了，因为那相当于没有复制到剪切板上，复制了个寂寞。

###### 系统剪切板(`"+`)与选择专用寄存器(`"*`)

前面讨论的都是VIM内部的寄存器。如果想从VIM复制文本到外部程序，则必须使用系统剪切板。

VIM的`+`寄存器与系统剪贴板等效

从外部程序复制或者剪贴了文本，可以通过`"+p`将其粘贴到VIM内部，如果指定使用了`+`寄存器，那么操作的文本会被系统剪贴板捕获。

> `:reg`命令可以看到刚刚从外部程序剪贴的文本内容存储在`+`和`*`寄存器中。

X11视窗系统支持另一种叫主剪贴板(primary)的剪贴板，它保存着上一次高亮选中的文本。可以用鼠标中键粘贴出来。
VIM的`*`寄存器对应主剪贴板。

| 寄存器 | 用途                              |
| :---   | :---                              |
| `"+`   | X11剪贴板，用剪切，复制和粘贴操作 |
| `"*`   | X11主剪贴板，用鼠标中键操作       |

WINDOWS和MAC OS X操作系统没有主剪贴板的概念，所以`+``*`寄存器可以混用。

X11剪贴板的功能可以在编译VIM时被激活或禁用。`:version`可以找到`xterm_clipborad`关键字，前面有`+`号表示功能已经激活，`-`号表示不支持该功能。


###### 表达式寄存器`"=`

VIM寄存器通常都是用用来保存一段文本的容器。然而，`=`号寄存器代表的表达式寄存器是例外。当从表达式寄存器获取内容时，VIM将跳到命令行模式，并显示`=`提示符。
这时，可以输入VIM脚本并`<CR>`执行，如果返回的是字符串(或可以被转成字符串的数据),VIM将使用它。

更多表达式寄存器用法，参考[技巧16](#16)、[技巧96](#96)、[技巧95](#95)以及[技巧71](#71).

###### 其他寄存器

除了可以显式使用删除与复制命令来设置有名、无名以及复制专用寄存器的内容之外，VIM还提供了几组可以隐式赋值的寄存器，它们被称作只读寄存器(`:h quote.`)。

| 寄存器 | 内容             |
|--------|------------------|
| `"%`   | 当前文件名       |
| `"#`   | 轮换文件名       |
| `".`   | 上次插入的文本   |
| `":`   | 上次执行的Ex命令 |
| `"/`   | 上次查找的模式   |

严格来说`/`寄存器是可以显式赋值的(`:h quote/`)，可以用`let @/ = "some string"`来复制，为了方便列入了上表

#### 技巧62 用寄存器内容替换高亮选区的文本

> VIM的粘贴命在可视模式下使用，会体现不同的特性。

可视模式下使用`p`命令，VIM会将指定的寄存器内容用来替换高亮选区的文本(`:h v_p`)

#####  交换两个词

`I like fish and chips` 改成 `I like fish and chips`

`fc`光标移动到`c`处，`de`删除chips并存放到无名寄存器中，`mm`设置位置标记，`ww` `ve`高亮选中`fish`,`p`将fish替换成`chips`,``m`回到标记处，`P`将fish粘贴。

#### 技巧63 将寄存器内容复制出来

将文本从寄存器中复制出来根据文本的类型不同会有不同的效果。

寄存器中的文本是面向字符的那`p`命令就是将文本复制到光标之后，`P`将文本复制到光标之前。

文本是面向多行的，那`p`就是将文本复制到光标所在行的下一行，`P`将文本复制到光标的上一行。
`gp`和`gP`也是将文本粘贴到当前行之前或之后，不同的是，它们会把光标位置移动到被粘贴的文本结尾而不是开头.

插入模式下，可以通过`<C-r>"`来插入无名寄存器的内容,`<C-r>0`来插入复制寄存器的内容.

#### 技巧64 与系统剪贴板进行交互


不同系统的系统复制粘贴命令不一样，但用系统的复制命令将文本复制到VIM可能会出现问题。

<kbd>Ctrl</kbd><kbd>v</kbd>是默认的LINUX和WINDOWS的粘贴命令，但VIM的`<C-v>`是进入VISTAL-BLOCK模式。而在插入模式下，它允许插入字符本身或字符编码。

有的终端提供不同的粘贴命令，避免和VIM冲突，但在插入模式下使用系统的粘贴命令，可能会出现下面这种情况：

`some string for test`

`[200~some string for test[201~]]`会多出奇怪的字符

VIM提供`paste`选项,启用该选项后，VIM将禁用所有插入模式下的映射项和缩写，并重置很多选项(`:h 'paste'`),这样就能安全的使用系统剪切板的粘贴操作了，
使用完后，还要关闭`paste`选项。这样切换需要运行`:set paste!`或`:set paste` `:set nopaste`几次，不是很方便。

由于启动`paste`选项后，么VIM插入模式下创建的自定义映射项都失效了，作为替代方案，可以把`pastetoggle`(`:h 'pastetoggle'`)映射成一个功能键。

`:set pastetoggle=<F5>`

实际上为了避免切换`paste`选项么，还是推荐使用`+`或`*`寄存器进行与系统剪贴板的交互。


### 第十一章 宏

VIM提供了不止一种方式用于重复之前的修改。`.`命令用于重复小的修改确实有效，但想重复更大规模的改动时，VIM的宏就派上用场了。

可以用宏把任意数目的按键操作录制到寄存器，用于之后的回放。

宏很适合对一系列相似的段落、行，甚至是文件进行重复修改。

在一组目标上执行宏有两种方式，串行方式回放或者并行方式多次运行。

宏可以修改和编辑，所以不用担心录制宏的时候出错。

#### 技巧65 宏的读取和执行

> 宏允许把一段修改序列录制下来，用于之后的回放。

##### 把命令录制成宏

`q`键既是录制按钮也是停止按钮。

`q{register}`指定用于保存宏的寄存器。当出现recording @时表示录制已经开始，此后，每执行一条命令都会被宏捕获，直到下次按下`q`键停下为止。

##### 查看宏

`reg {register}`，因为保存宏都是保存在寄存器里，所以查看宏就用查看寄存器的命令就行。

##### 通过执行宏来回放命令序列

`@{register}`命令执行执行寄存器的内容，也可以通过`@@`来重复最近调用的宏。

##### 以串行方式执行宏

串行方式执行宏,只要某一点出现问题，那么执行过程会停止。就像电路的串联，一处断开，整个电路断路。

##### 以并行方式执行宏

并行方式执行宏，几组电线并联连接，一条断路，其他并行电路仍然工作。

> 实际上并行和串行执行就是碰到问题是否会终止，并行并不是同时执行，互不干扰，实际上执行宏还是一次一次的执行的，只不过并行执行遇见错误会继续执行，这一点可以在[技巧72](#72)中编号`i`的值变化上看到。

#### 技巧66 规范光标位置、直达目标以及终止宏

> 在执行宏的过程中，有时会产生意外的结果，但如果遵从一些最佳的应用方式，就能取得更好的一致性。

##### 规范光标的位置

每次总是从确定的位置开始执行的话，命中正确的目标会更容易。`0`会将光标放到每行开头,`^`会将光标移动到每行第一个非空字符。

##### 用可重复的动作命令直达目标

VIM有一组丰富的动作命令集，使用动作命令能使宏具有灵活性和可重复性。录制宏的过程中禁止使用鼠标。

##### 动作命令失败时，宏将终止执行

宏的执行动作命令失败了，VIM将终止执行其余的宏命令，这是一个功能，而不是漏洞。

#### 技巧67 加次数回放宏

> 对重复次数不多的工作，点范式是一种高效的编辑策略，但它不能指定执行的次数

[技巧3](#3)中用过的点范式需要多次执行`;.`来重复,但如果有很多需要修改的地方，执行多次`;.`也是一个很大工作量。

这时可以录制一个简单的宏:`qq;.q`再输入`22@q`就可以执行22次`;.`命令，因为执行失败时宏会自动退出，所以可以用`22`因为2和`@`是一个键.

单纯使用`;.`不能达到多次使用的目的`22;.`和`;22.`都不能达到目的。

不是所有宏都能用估算次数的方式，`22@q`是因为上面的命令有`;`查找的安全退出机制。

#### 技巧68 在连续的文本行上重复修改

对于多行范围的重复性移动，可以先录制一个宏，然后再在每一行上回放

```
1. one
2. two
3. three
4. four
```
变成
```
1) One 
2) Two 
3) Three
4) Four
```

串行执行：

`qa`开始录制，`0f.r)w~j`录制命令，`q`结束录制。
录制完成后`4@a`会重复执行4次宏命令

并行执行：
`qa`开始录制，`0f.r)w~`录制宏，`q`结束录制,`V3j`选中下三行，`:`进入命令行模式，VIM会自动填充`:'<,'>`，完成命令`:'<,'>normal @a`会对选区并行执行录制的宏。

#### 技巧69 给宏追加命令
> 有时候，在录制宏的过程中会漏掉某个步骤，在这种情况下，没必要从头开始所有步骤，而是可以在宏的结尾添加额外的命令。

前面说过宏是录制好放在寄存器中的，而寄存器用大写字母是追加内容，寄存器也一样，`qa`是录制宏并放到`a`寄存器，`qA`就是追加宏命令到`a`寄存器。

碰到需要修改宏开头或中间的某个位置添加内容这种方法就不行了，[技巧72](#72)中有更好的方法修改录制好的宏。

#### 技巧70 在一组文件中执行宏

`args *.tb`将当前目录下所有tb文件添加到参数列表，`qa`进行录制宏，`q`退出,先不要保存，因为将会用`argdo normal @a`对参数列表中的所有缓冲区执行刚录制的宏,
如果保存了那录制宏的文本会又一次执行录制的宏命令。用`:edit!`放弃对第一个缓冲区进行的修改，然后就可以执行`:argdo normal @a`执行宏了。

如果使用了`:first`，`:next`等操作就可以使用串行方式执行宏，在宏命令最后添加`:next`那执行一次宏完毕就会切换到另一个缓冲区,执行到最后一个缓冲区的`:next`命令会失败，宏就会终止退出。

执行完宏后要对所有文件进行保存，`:wall`将会对所有缓冲区保存，这和`:argdo write`不同，`:argdo`只会对参数列表的缓冲区执行操作。

#### 技巧71 用迭代求值的方式给列表编号

```
first line
second line
third line
```
给上面的行编号：
```
1) first line
2) second line
3) third line
```

`:let i = 1`设置变量用来计数，`qa`开始录制，`I`在开头插入，`<C-r>=i`使用表达式寄存器，`) `加括号，`<ESC>q`,`Vjj`选中下面两行，`:`进入命令行模式,完整命令`:'<,'> normal @a`并行执行。

复制、粘贴和`<C-a>`也可以实现相同的工作。

#### 技巧72 编辑宏的内容

[技巧68](#68)中使用的宏只针对将小写全部大写，所以用了`~`，那如果有的已经是大写了，这样录制的宏就会出问题，所以需要进行修改.

想要修改宏，要先将宏粘贴到文档中,最简单的方式是`:put {register}`命令，因为`"ap`会将文本粘贴到光标之后，而`:put`总会将文本粘贴到当前行的下方，无论寄存器中是行文本还是块文本。

将宏粘贴到文档后就可以像编辑文档一样编辑宏，编辑完成后再将文本复制回寄存器。

复制回寄存器的过程最简单是`"add`或者`:d a`但是这样会出现一个问题，dd命令执行面向行的删除操作，会再文本后加上一个拖尾字符`^J`

`^J`表示一个换行符，且再多数情况下，该字符无关紧要，但有时候仍然会影响宏的使用，为了保险起见，用面向字符的操作将文档复制回寄存器会更安全。

----
> VIM的寄存器不过是一些保存文本串的容器，可以像变量一样操作它们.
> 例如用`substitute()`函数修改上述宏
> `:let @a=substitute(@a,'\~','vU','g')`
> 具体用法`:h function-list`
----


## 第五部分　模式(pattern)

这部分专门介绍`patterns`，对与查找和替换命令来说，模式是必不可少的。这部分介绍了一些技巧，使得构造正则表达式以及按原义查找文本更容易。

### 第十二章 模式匹配和原义匹配

vim 的正则表达式引擎需要注意的点：

- `very magic`模式
- `very nomagic`原义开关
- 查找域(search field)
- 特殊元字符，零宽度定界符 
- 即使使用了`\V`原义开关仍具有特殊含义的字符

#### 技巧73 调整查找模式的大小写敏感性

> 既可以全局性地调整VIM的超照功能的大小写敏感性，也可以在每次查找时进行局部调整。

##### 全局设置大小写敏感性

`:set ignorecase`
这项设置会影响到VIM关键字的自动补全功能。

##### 每次查找时设置大小写敏感性

使用元字符`\c`和`\C`可以覆盖VIM默认的大小写敏感性设置。`\c`会忽略大小写，`\C`会强制区分大小写。

> 这两个元字符可以出现在模式的任意位置。假如已经输入了完整的模式才发现需要区分大小写，这时只需要在结尾添加`\C`，该元字符就会作用于整个模式。

##### 更智能的大小写敏感性设置

VIM提供一项额外功能，用于最大限度推测我们想使用大写还是小写。

`smartcase`选项，该选项设置后，只要在模式中输入了大写，查找就会区分大小写，只要全小写，就会按照忽略大小写的方式查找。

#### 技巧74 按正则表达式查找时，使用`\v`模式开关

> 和Perl相比，VIM正则表达式的语法风格更接近POSIX，但是使用very magic 模式开关，可以让VIM采用我们熟悉的Perl正则表达式语法。

假设要构造正则表达式，匹配CSS文件中的颜色代码：

```
/#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)
```

> VIM的模式里方括号默认是特殊含义，不用转义，圆括号默认按原义匹配，因此需要转义，花括号也一样需要转义，不过只需为开的花括号转义，与之对应的闭括号不必须转义，因为VIM会推测意图，圆括号则开闭都必须转义

三类括号在模式中的规则都不同，需要牢记，不然很影响正则的阅读。

##### 使用very magic 搜索模式查找十六进制颜色代码

可以利用`\v`模式开关来统一所有特殊符号的规则。该元字符将会激活very magic搜索模式，即假定除下划线、大小写字母以及数字0-9之外的所有字符都具有特殊含义。(参见`:h \v`)

  ```
  /\v \/V
  Use of "\v" means that after it, all ASCII characters except '0'-'9', 'a'-'z',
  'A'-'Z' and '_' have special meaning: "very magic"

  ```

`\v`开关使VIM的正则表达引擎表现的更像perl、python或Ruby。尽管如此，它们之间仍然存在差异，关于这一点，需要时刻留意，但是与规定哪个必须转义哪个不得转义相比，`\v`模式开关的规则更容易记忆。

`/\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})`

在模式的开头使用`\v`开关，它后面的所有字符都具有特殊含义，这样就不用写那么多反斜杠，可读性更强了

##### 用十六进制字符类进一步优化模式

`\x`可以替代完整的字符集`[0-9a-fA-F]`(参见`:h /character-classes`),`\x`表示十六进制数。

`/\v#(\x{6}|\x{3})`


需要说明的是`#`没有特殊含义，因此可按原义匹配，可`:h \v`上说的是除了下划线、英文字母和数字之外都是具有特殊意义的，那`#`就是特例了？
VIM的解释是任何还未具有特殊含义的字符都被保留以备将来扩展时使用，换句话说，现在`#`不具备特殊含义，但是不意味着将来的版本不具备特殊含义。

> 两套正则表达式引擎
> VIM7.4引进了一套新的正则表达式引擎(`: new-regexp-engine`)，旧的引擎是回溯算法，而新的引擎采用了状态机算法，
> 因此在处理复杂模式和长文本时表现更为优异，这次优化使所有用正则表达式的功能在效率上都有所提升，
> 例如语法高亮，查找命令以及`vimgrep`
> 新的正则表达式默认激活，但旧的引擎仍然存在，新引擎对于有些正则表达式的功能还不支持，当某个模式用到这写功能时，VIM会自动切换到旧的引擎(`:h two-engine`)

#### 技巧75 按原义查找文本时，使用`\V`原义开关

> 上面的技巧按模式查找时很方便，但想要按原义查找时就会很麻烦，这时就要使用`very nomagic`原义开关，可以消除在`.`,`*`以及`?`等大多数字符上的特殊含义。

如果要匹配`a.k.a.`这个字符串:

```
The N key searches backward ...
... the \v pattern switch (a.k.a. very magic search)
```

`/a.k.a.`会发现匹配到`backward`，这是因为`.`号有特殊含义，表示匹配任意字符，而`backward`的部分内容也匹配该模式。

只是查找命令还行，不会造成多大问题，但使用替换命令时出现这种问题就会导致意想不到的错误。

使用转义方法消除字符的特殊含义：

`/a\.k\.a\.`

使用原义开关`\V`激活`very nomagic`搜索模式:

`/\Va.k.a.`

使用了`\V`会使得其后的模式中只有反斜杠`\`有特殊意义

想要用正则查找，就用`\v`，想按照原义查找，就用`\V`

> VIM模式语法的传承
> 对VIM模式来说，除了`\v`和`\V`开关代表very magic 和 very nomagic之外,
> 还有更古老的magic模式和nomagic模式，用于模拟vi的行为，可以通过`\m`和`\M`开关使用。
> 但由于这两个模式转义规则上的缺陷，导致转义规则比较混乱，难以记忆
> `\v`和`\V`正好弥补这一点，且更好记忆，又恰好和Perl正则表达式的规则一致，所以现在都使用`\v`和`\V`


#### 技巧76 使用圆括号捕获子匹配

> 但指定一个模式时，可以捕获其子匹配，并在其他地方引用它，这个功能和`substitute`命令结合尤为好用

下面是我自己用来给python字典加引号用的替换命令
```
" 将从浏览器复制的键值对复制到{}中后执行命令
" 范围是从{ 到  }
"/{/;/}/ s/\(\<.*\>\):\s\(.*\)$/'\1':'\2',/

" 改进
?{?,/}/ s/\(\<.*\>\):\s\(.*\)$/'\1':'\2',/g

" 使用\v开关
" ?{?,/}/ s/\v(<.*>):\s(.*)$/'\1':'\2',/g
Format

```

书中给出的用来匹配重复单词的正则表达式：
`/\v<(\w+)\_s+\1`

```
the the
```

圆括号内部的匹配文本会自动保存到临时仓库，可以用`\1`引用被捕获的文本，如果不止一处圆括号，则可以用`\1`、`\2`直到`\9`来引用每对被`()`捕获的子匹配。另外，不管是否使用了`()`元字符`\0`永远引用整个匹配.

`\v`激活very magic模式，`<`和`>`匹配单词边界，`\_s`会匹配空白符或换行符(`:h /\_`和`:h 27.8`)

#### 技巧奥77 界定单词的边界

> 在定义模式时，如果能指定单词从哪里开始到哪里结束，将会非常有用.

```
the these they their
```
这些单词都有`the`如果只想匹配`the`这一个单词，用`/the<CR>`,那实际匹配的结果会比想要的多。

如果想要明确匹配`the`这一个完整的单词，而不是其他单词的组成部分，就需要使用单词定界符。

在very magic模式下，`<`和`>`表示单词定界符，`/\v<the><CR>`就可以只匹配`the`这一个单词了。

这就是所谓的零宽度元字符，他们本身不匹配任何字符，仅表示单词与围绕此单词的空白字符(或标点符号)之间的边界。

> 使用圆括号，但不捕获内容
> 有时候只想使用圆括号的分组功能，但不关心捕获的子匹配的使用，例如：
> `/\v(AND|D)rew Neil`
> 这里就不想使用子匹配，只想使用分组功能。
> 在圆括号前加`%`VIM就不会将括号内的内容赋值给寄存器`\1`
> `/\v%(AND|D)rew Neil`
> 这样做得好处时速度比原来快一点，只是可能察觉不到，但是当表达式更复杂或处理的文本更多时就明显了。
> 当使用多组圆括号时，这样做的好处就体现出来了
> `/\v(%(And|D)rew) (Neil)`
> `:%s//\2,\1/g`
> 该查找模式会把`Andrew`或`Drew`赋值给寄存器`\1`而把`Neil`赋值给`\2`寄存器，如果没有第二组括号前的`%`，就会得不到想要的结果，因为替换域被扰乱了。

`\W\ze\w`模拟元字符`<`，而`\w\ze\W`表示元字符`>`.

在`very magic`模式下，`<`和`>`可以直接解析为单词定界符，而`magic`、`nomagic`和`very nomagic`模式下都需要转义,所以想要查阅这些选项，需要在前面加转义符`:h /\<`

`*`和`#`命令会正向和反向查找光标下的单词，假设刚用过这两个单词，再查看查找历史就会发现上一次的查找模式被单词定界符包围在中间。

btw `g*`与`g#`会执行同样的查找，但不会使用单词定界符.

#### 技巧78 界定匹配的边界

> 有时候，可能想指定一个范围较广的模式，但是只对匹配结果的一部分感兴趣，VIM的元字符`\zs`与`\ze`可以帮助我们处理这种情况。

一个匹配的边界通常是模式的起始与结尾，但可以用元字符`\zs``\ze`对匹配进行裁剪，使其称为这个完整模式的一个子集(`:h \/zs`)。元字符`\zs`标志匹配的起始，`\ze`标志匹配的结束，二者结合，可以定义一个特殊的模式，它可以让我们定义一个模式匹配一个较大的范围，然后再收窄匹配范围。与单词界定符一行，`\zs\ze`均属于零宽度元字符。

例子：

`/Practical VIM<CR>`会 高亮所有文中出现"Practical VIM"的地方(如果开启了`:set hlsearch`)，但将模式改成`/Practical \zsVIM\ze<CR>`则只有单词"VIM"会被高亮。

> VIM的正则和Perl有所区别，二者的逐项对比查阅`:h perl-patterns`

#### 技巧79 转义问题字符

> `\V`原义开关使得按照原义查找文本变得更容易，因为符号`.+*`的特殊含义被屏蔽掉了。但还有一些字符的特殊含义无法屏蔽，这一节是高级技巧，研究如何处理这些字符。

```
Search items: [http://vimdoc.net/search?q=/\\][s]
...
[s]: http://vimdoc.net/search?q=/\\
```
假设要找到所有出现过URL`http://vimdoc.net/search?q=/\\`的地方，不必手动输入这些内容，只需要将其复制到某个寄存器，再粘贴到查找域即可。由于是想精确匹配这些原文，所以使用`\V`原义开关，

`"uyi[`将URL放到寄存器`u`,`/\V<C-r>u<CR>`将寄存器内容填充到查找域。

完整命令：`\Vhttp://vimdoc.net/search?q=/\\`


但是执行命令时会发现，只匹配了`http:`

这是因为VIM把首次出现的`/`当成了查找域结束符,因此所有位于首个正斜杠之后的内容都被忽略掉了，所以查找字符串只剩下`http:`

> 查找域结束符:
> 为什么查找域会某个字符当作是结束符呢？答案是再查找域结束符之后加某些标志位，可以调整VIM查找命令的行为，例如：
> `/vim/e<CR>`光标将会移动到每个匹配的末尾而不是起始。
> 替换命令的使用`:s/{pattern}/{string}/`里面的`/`也起到这种作用，当你使用了`/`而没转义，那VIM就认为`/`是模式的结束

所以，进行正向查找`/`时,必须转义符号`/`,而且无论执行的是very magic 还是very nomagic都需要进行转义。

修改后：
`/\Vhttp:\/\/vimdoc.net\/search?q=\/\\`

但仍会有问题，会漏掉最后一个`\`，因为反斜杠是用来转义其他字符的,有特殊意义，`\\`一起表示匹配一个`\`只有`\\\\`才是表示俩个反斜杠。

最终版本：
`/\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\`

这样就能正确匹配整个URL`http://vimdoc.net/search?q=/\\`了

如果是反向查找：

`?\Vhttp://vimdoc.net/search\?q=/\\\\`

因为反向查找查找域的开始和结束都是`?`所以使用反向查找问号要转义。

> 反斜杠`\`是转义字符，不管是正向查找还是反向查找， 想要原义匹配它都需要用转义`\\`

##### 用编程方式转义字符

手动转义的方式耗时费力，又容易出错，VIM提供了一个库函数，帮助我们完成这项任务：`escape({string},{chars})`(参见`:h escape()`)

`{chars}`指定那些字符需要用反斜杠转义，如果是正向查找`escape(@u, '/\')`,他会把寄存器`u`中的文本每一个`\`和`/`加上反斜杠前缀。
但如果是反向查找：`escape(@u, '?\')`，他会把问号和反斜杠加上反斜杠前缀。

首先确保url存放在`u`寄存器，然后按`/`或`?`调出查找提示符，再输入`\V`原义开关，按`<C-r>=`打开表达式寄存器:

`=escape(@u, getcmdtype().'\')`

按下`<CR>`后，escape函数会执行，返回值会被插入到查找域，如果在执行正向查找，`getcmdtype()`函数返回符号`/`反向查找返回`?`。

> VIM脚本中`.`用来连接字符串.

切换到表达式寄存器的状态以及手动调用escape()函数，仍然会涉及很多输入，如果再多一点vim脚本，操作即可实现自动化，[技巧87](#87)可供参考。


### 第十三章 查找


#### 技巧80 结识查找命令

##### 执行一次查找

普通模式下，`/`键会调出VIM查找提示符，在它后面输入要查找的模式或原义文本，只有按下`<CR>`才会执行查找，按`<ESC>`提示符会消失，重回普通模式

默认查找命令抵达文档底部时会回到文档开头继续查找，如果只想在当前光标位置到文档结尾的范围内查找，可以关闭回绕选项`wrapscan`(`:h 'wrapscan'`)

##### 指定查找方向

`/`执行查找，VIM会正向扫描文档，`?`执行查找，VIM会反向查找。

##### 重复上一次查找

`n`命令用于跳转到下一处匹配，`N`命令用于跳转到上一处匹配，这里的上一处和下一处方向不是固定的，取决于使用的是`?`还是`/`,`?`的下一处是向上查找，`/`的下一处是想下查找。

| 命令    | 用途                                     |
|---------|------------------------------------------|
| `n`     | 跳至下一处匹配，保持查找方向与偏移不变   |
| `N`     | 跳至上一处匹配，保持查找方向与偏移不变   |
| `/<CR>` | 正向跳转至相同模式的下一处匹配           |
| `?<CR>` | 反向跳转至相同模式的下一处匹配           |
| `gn`    | 进入面向字符的可视模式，并选中下一处匹配 |
| `gN`    | 进入面向字符的可视模式，并选中上一处匹配 |

##### 回溯之前的查找

VIM会一直记录我们执行过的查找模式，因此可以方便重用它们。实际上，查找历史和命令行历史的接口完全一致，[技巧34](#34)中讨论过这些.

#### 技巧81 高亮查找匹配

查找命令能在诸多匹配中快速跳转，但默认不会将这些匹配可视化凸显出来，启用`hlsearch`选项，可以高亮显示匹配的项.`:set hlsearch`

**禁用高亮查找**

如果查找的字符到处都是，启用了高亮查找之后到处都是高亮的色块，
这时想禁用高亮查找可以用`:set nohlsearch`彻底禁用(`:set nohls`和`:set hls!`是一样效果的).

一种更好的方法是暂时关闭高亮查找功能。(`:h :noh`),`:nohlsearch`命令暂时关闭查找高亮.直到执行新的或重复的查找命令为止。

> 创建用于关闭高亮功能的快捷键
> `nnoremap<silent> <C-l> :<C-u>nohlsearch<CR><C-l>` 
> `<C-l>`通常用于清除并重绘显示屏，新的映射在原有基础上添加了暂时关闭高亮查找的功能

#### 技巧82 在执行查找前预览第一处匹配

> 激活增量查找功能后，VIM的查找命令会如虎添翼

默认情况下，只有按下`<CR>`VIM才会开始查找。`incsearch`功能能让VIM根据已在查找域中的文本，预览第一处匹配，每输入一个新的字符，vim会即时更新预览内容。

开启`incsearch`后，只有按`<CR>`才会跳转到匹配项，按`<CR>`之前都不会跳转，只是预览而已，所以按`<ESC>`会回到光标原来位置。

这样可以知晓模式是否已经匹配到目标。

也可以检查是否存在一处匹配：我想知道技巧32的笔记是否做了，只需要`/# 技巧32`，如果做了就会预览到技巧32的位置,然后`<ESC>`退回当前光标所在。


##### 根据预览结果对查找域自动补全

之前说过，在命令行模式下`<C-r><C-w>`会将光标下的单词复制到命令行，
那设置了`incsearch`后预览匹配结果的光标也可以这样使用,在查找单词和词组时，输入一半，例如`/carr`预览到`carrot`是我们想要查找的单词，不用输入后面的`ot`只需要`<C-r><C-w>`就可以自动补全`/carrot`,但是当使用模式进行查找时，`<C-r><C-w>`会将光标下的完整单词补全到查找域`/\vcarr`会变成`/\vcarrcarrot`，所以这个补全功能一般更适用于字符串的查找。


#### 技巧83 将光标偏移到查找匹配的结尾

> 可用查找偏移将光标定位于某个距离匹配的起始或结尾一定步长的位置。

查找命令会将光标定位于匹配的文本的首个字母上。
当我们想要将光标定位查找匹配的结尾，VIM的查找偏移功能可以实现(`: search-offset`)


